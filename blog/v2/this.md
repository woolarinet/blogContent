---
id: 3
img: javascript/js-thumb.png
title: [코어 자바스크립트] 03.this
commentor: sunho
date: 15 July 2021
tag: javascript, core-javascript
description1: 
description2: this에는 호출한 주체의 정보가 담긴다.
descriptions:
전역 공간에서 this는 전역 객체를 가리킨다. 전역 컨텍스트를 생성하는 주체가 전역 객체이기 때문이다. 자바스크립트의 모든 변수는 특정 객체의 프로퍼티로서 동작한다. 따라서 전역변수를 선언하는 경우는, 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당한다.
예를 들어, 전역에서 a변수를 선언 및 할당 후 a를 직접 호출할 때, 스코프 체인에서 a를 검색하다가 마지막에 도달하는 전역 스코프의 LexicalEnvironment, 즉 전역객체에서 해당 프로퍼티 a를 발견해서 그 값을 반환한다. (i.e. (window.)a)
따라서 대부분의 경우에는 전역 공간에서 var로 변수를 선언하는 대신, window의 프로퍼티에 직접 할당하더라도 결과적으로 var로 선언한 것과 똑같이 작동한다. 다른 경우가 하나 있는데, 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 delete 명령에 대한 경우다.
즉, 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configureable 속성을 false로 정의하는 것이다. 이처럼 var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보인다.
메서드 내부에서 호출 주체는 바로 함수명 앞의 객체가 된다. 명시된 객체가 this가 된다.
함수로써 호출할 때 내부의 this는 지정되지 않는다. this에는 호출한 주체의 정보가 담겨야하는데 함수로서 호출하는 것은 호출 주체를 명시하지 않고 개발자가 직접 코드에 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다. 하지만 이는 설계상 오류라는 지적이 있다.
그렇다면 메소드 내부의 함수에서 호출하는 경우는 어떨까? 역시, 내부의 this가 지정되지 않기에 global을 가리키게 된다. 따라서 메소드 내부에서 함수를 작성할 때는 우회하여 작성하고는 했다.
ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자 'arrow function'을 도입하였다. arrow function은 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다. 이 경우에는 '우회법'이 불필요하다.(ES5 환경에서는 arrow function을 사용할 수 없음)
자바스크립트는 함수에 생성자(클래스)로서의 역할을 함께 부여하기에 new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작한다. 그리고 그 경우 생성자 함수 내부의 this는 새로 만들 구체적인 인스턴스 자신이 된다.
지금까지는 명시적 this바인딩이 없는 경우이다. 그렇다면 명시적으로 this바인딩이 있을 때는 어떨까?
call, apply 메서드는 this를 명시적으로 지정하며 함수 또는 메서드 호출하며 bind 메서드는 this 및 함수에 넘길 인수를 일부 지정하여 새 함수를 생성한다. 요소를 순회하며 콜백함수를 반복호출하는 메서드는 별도의 인자로 this를 받기도 한다.
---
